// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package message

import (
	"sync"
)

// Ensure, that CacheMock does implement Cache.
// If this is not the case, regenerate this file with moq.
var _ Cache = &CacheMock{}

// CacheMock is a mock implementation of Cache.
//
//	func TestSomethingThatUsesCache(t *testing.T) {
//
//		// make and configure a mocked Cache
//		mockedCache := &CacheMock{
//			ExistsFunc: func(v string) bool {
//				panic("mock out the Exists method")
//			},
//			RemoveFunc: func(v string)  {
//				panic("mock out the Remove method")
//			},
//			SetFunc: func(v string)  {
//				panic("mock out the Set method")
//			},
//		}
//
//		// use mockedCache in code that requires Cache
//		// and then make assertions.
//
//	}
type CacheMock struct {
	// ExistsFunc mocks the Exists method.
	ExistsFunc func(v string) bool

	// RemoveFunc mocks the Remove method.
	RemoveFunc func(v string)

	// SetFunc mocks the Set method.
	SetFunc func(v string)

	// calls tracks calls to the methods.
	calls struct {
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// V is the v argument value.
			V string
		}
		// Remove holds details about calls to the Remove method.
		Remove []struct {
			// V is the v argument value.
			V string
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// V is the v argument value.
			V string
		}
	}
	lockExists sync.RWMutex
	lockRemove sync.RWMutex
	lockSet    sync.RWMutex
}

// Exists calls ExistsFunc.
func (mock *CacheMock) Exists(v string) bool {
	if mock.ExistsFunc == nil {
		panic("CacheMock.ExistsFunc: method is nil but Cache.Exists was just called")
	}
	callInfo := struct {
		V string
	}{
		V: v,
	}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc(v)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//	len(mockedCache.ExistsCalls())
func (mock *CacheMock) ExistsCalls() []struct {
	V string
} {
	var calls []struct {
		V string
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}

// Remove calls RemoveFunc.
func (mock *CacheMock) Remove(v string) {
	if mock.RemoveFunc == nil {
		panic("CacheMock.RemoveFunc: method is nil but Cache.Remove was just called")
	}
	callInfo := struct {
		V string
	}{
		V: v,
	}
	mock.lockRemove.Lock()
	mock.calls.Remove = append(mock.calls.Remove, callInfo)
	mock.lockRemove.Unlock()
	mock.RemoveFunc(v)
}

// RemoveCalls gets all the calls that were made to Remove.
// Check the length with:
//
//	len(mockedCache.RemoveCalls())
func (mock *CacheMock) RemoveCalls() []struct {
	V string
} {
	var calls []struct {
		V string
	}
	mock.lockRemove.RLock()
	calls = mock.calls.Remove
	mock.lockRemove.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *CacheMock) Set(v string) {
	if mock.SetFunc == nil {
		panic("CacheMock.SetFunc: method is nil but Cache.Set was just called")
	}
	callInfo := struct {
		V string
	}{
		V: v,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	mock.SetFunc(v)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedCache.SetCalls())
func (mock *CacheMock) SetCalls() []struct {
	V string
} {
	var calls []struct {
		V string
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}
